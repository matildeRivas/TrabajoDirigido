from igraph import *
import psycopg2
from psycopg2.extensions import AsIs
from psycopg2.extras import execute_values
import sys
from config import config
import numpy as np
from pprint import pprint


def main(argv):
	if (len(sys.argv) < 3 or len(sys.argv) > 3):
		print(
			"Debe ingresar nombre de mapa de caminos y nombre de mapa con puntos a conectar")
	else:
		map_name = argv[1]
		points_name = argv[2]
		conn = None
		try:
			# read connection parameters
			params = config()
			# connect to the PostgreSQL server
			print('Connecting to the PostgreSQL database')
			conn = psycopg2.connect(**params)
			print('Connected!\n')
			# create a cursor
			# conn.cursor will return a cursor object, you can use this cursor to perform queries
			cursor = conn.cursor()
			# execute queries
			# create a results table
			needed_paths_name = map_name + "_construccion"
			cursor.execute(
				"CREATE TABLE IF NOT EXISTS %s  (path_id int, id int generated by default as identity PRIMARY KEY);",
				(AsIs(needed_paths_name),))
			find_paths(map_name, points_name, cursor, needed_paths_name)
			# close communication with the PostgreSQL database server
			cursor.close()
			# commit the changes
			conn.commit()
		except (Exception, psycopg2.DatabaseError) as error:
			print(error)
		finally:
			if conn is not None:
				conn.close()


# find two disjoint paths between each pair of points, except for capital cities
def find_paths(map_name, points_name, cursor, needed_paths_name):
	# create graph from map linestrings, in which the vertex name is its postgis geometry, edge weight is the building cost and edge id is the corresponding id in table
	cursor.execute("select origen, fin, id, costo from %s where camino notnull;", (AsIs(map_name),))
	edges = cursor.fetchall()
	graph = Graph.TupleList(edges, directed=False, vertex_name_attr="name", edge_attrs=("id", "weight"))

	# get valid points (comunas)
	points = get_points(cursor, map_name, points_name)

	# create a grid to mark found paths
	points_grid = np.zeros((len(points), len(points)))

	# fill the grid's diagonal
	np.fill_diagonal(points_grid, 2)

	# get capital cities
	capitales = get_capitals(cursor)

	# for each point we must connect
	for p in range(len(points)):
		print("buscando desde comuna ", p)

		# list of target comunas
		target = compute_targets(graph, points, points_grid, p)

		# source vertex associated to p
		s = graph.vs.find(name=points[p])

		# list of disjoint paths from s to each target
		paths = suurballe(graph, s, target)

		# process paths to obtain the corresponding table IDs
		all_ids = process_suurballe_paths(paths, p, graph, points, target, points_grid)

		# capitals must have three paths
		if p in capitales:
			thrid_path = find_third_path(graph, s, all_ids, target, points_grid)
			all_ids = all_ids + thrid_path

		# add IDs to psql table
		update_table(needed_paths_name, cursor, all_ids)
	pprint(points_grid)


def process_suurballe_paths(paths, p, graph, points, target, points_grid):
	all_ids = []
	# for each comuna's paths
	for path in paths:
		# first and second are tuple lists like ((i, j), id)
		first = path[0]
		second = path[1]
		# obtain target point corresponding to paths
		target_index = paths.index(path)
		point_index = points.index(graph.vs[target[target_index]]['name'])

		# fill points grid accordingly
		not_empty = fill_grid(points_grid, p, point_index, first, second)

		# add paths to list of needed paths
		if not_empty:
			path_ids = []
			for (i, j), id in first + second:
				path_ids.append((id,))
			all_ids.append(path_ids)
	return all_ids


# returns the points that don't yet have 2 paths to 'p'
def compute_targets(graph, points, points_grid, p):
	target = []
	# for each point
	for q in range(len(points)):
		# if it hasn't been computed
		if points_grid[p][q] == 0:
			t = graph.vs.find(name=points[q])
			target.append(t.index)
	return target


# fills points grid given paths from source to target and returns if there paths were not empty
def fill_grid(points_grid, source_index, target_index, first, second):
	# si ambos caminos existen
	if first != [] and second != []:
		points_grid[source_index][target_index] += 2
		points_grid[target_index][source_index] += 2
		return True
	elif (first != [] and second == []) or (second != [] and first == []):
		points_grid[source_index][target_index] += 1
		points_grid[target_index][source_index] += 1
		return True
	else:
		return False


# returns two disjoint shortest paths from source vertex to each point in target_list
def suurballe(graph, source, target_list, directed=False):
	if directed == False:
		graph.to_directed()
	# get shortest path to target vertices using Dijkstra
	edge_path = graph.get_shortest_paths(source, weights="weight", to=target_list, output="epath")

	# get shortest distance to all vertices using Dijkstra
	distance = graph.shortest_paths(source, weights="weight")[0]

	shortest_path = get_edges(graph, edge_path)
	# problem_vertex contains vertices without two paths
	problem_vertex = []
	result = []

	# create transformed graph Gv for each V. Future: one unified graph
	for t in range(len(target_list)):
		v = graph.vs.find(target_list[t]).index
		if (distance[v] != float("inf") and target_list[t] != source):
			gv = create_graph(graph, distance, edge_path, t)
			transformed_path = gv.get_shortest_paths(source, weights="weight", to=target_list[t], output="epath")
			shortest_transformed = get_edges(gv, transformed_path)[0]
			# unify paths discarding edges that are in both paths
			union = unify_paths(shortest_transformed, shortest_path[t])
			# obtain paths from union
			path_1 = get_path(union, source.index, v)
			try:
				path_2 = get_path(union, source.index, v)
				# success.append(v, path_1, path_2)
				pair = (path_1, path_2)
				result.append(pair)
			except Exception:
				result.append((path_1, []))
				problem_vertex.append(v)
		# if vertex is unreachable
		elif distance[v] == float("inf"):
			result.append(([], []))
			problem_vertex.append(v)

		else:
			result.append([])
	return result


# find a third disjoint path between source and target
def find_third_path(graph, source, path_ids, target, points_grid):
	paths = []
	for i in range(len(path_ids)):
		# for psql reasons the format is (id,)
		edge_index = graph.es.select(lambda edge: (edge["id"],) in path_ids[i])
		# copy the graph so we can delete the edges
		graph_copy = graph.copy()
		graph_copy.delete_edges(edge_index)
		# we only need the first element because there's only one target
		path = graph_copy.get_shortest_paths(source, weights="weight", to=target[i], output="epath")[0]
		for s in range(len(path)):
			# obtain actual edge id
			id = graph_copy.es.find(path[s])["id"]
			path[s] = id
		update_grid(points_grid, source, target[i])
		paths.append(path)
	return paths


# todo delete path_ids from graph
#			compute djisktra from p to target
#			return those paths and add them to list
#			update grid


# insert paths into table
def update_table(table_name, cursor, path_ids):
	query = "insert into " + table_name + " (path_id) values %s;"
	execute_values(cursor, query, path_ids)


# sum 1 in specific point
def update_grid(points_grid, source, target):
	points_grid[source][target] += 1
	points_grid[target][source] += 1


def create_graph(original_graph, distance, edge_path, target):
	gv = Graph(directed=True)
	gv.add_vertices(len(original_graph.vs))
	reverse_edges(gv, original_graph, edge_path, target)
	gv.es["weight"] = transform_attributes(original_graph, distance)
	return gv


def unify_paths(path1, path2):
	for ((x, y), z) in path1:
		if ((y, x), z) in path2:
			path2.remove(((y, x), z))
			path1.remove(((x, y), z))
	return path2 + path1


def reverse_edges(gv, graph, edge_path, v):
	gv_edge_id = []
	for e in range(len(graph.get_edgelist())):
		edge = graph.es[e]
		source = edge.source
		target = edge.target
		if e in edge_path[v]:
			gv.add_edge(target, source)
			gv_edge_id.append(edge["id"])
		else:
			gv.add_edge(source, target)
			gv_edge_id.append(edge["id"])
	gv.es["id"] = gv_edge_id


# returns edges in edge_path as source and target IDs and edge ID
def get_edges(graph, edge_path):
	edges = graph.get_edgelist()
	edges_as_pairs = []
	for path in edge_path:
		path_pairs = []
		for e in path:
			path_pairs.append((edges[e], graph.es[e]["id"]))
		edges_as_pairs.append(path_pairs)
	return edges_as_pairs


def get_path(edges, source, target):
	path = []
	edges.sort(key=lambda x: (x[1], x[0]))
	try:
		current = search_tuple(edges, target)
		path.append(current)
		while (current[0][0] != source):
			current = search_tuple(edges, current[0][0])
			path.append(current)
	except Exception:
		raise Exception
	return path


def search_tuple(tups, elem):
	result = list(filter(lambda tup: tup[0][1] == elem, tups))
	try:
		tups.remove(result[0])
		return result[0]
	except IndexError:
		raise Exception


def transform_attributes(graph, distance):
	transformed_costs = []
	for i in range(len(graph.es)):
		d_target = distance[graph.es[i].target]
		d_source = distance[graph.es[i].source]
		if d_target == float("inf") or d_source == float("inf"):
			transformed_costs.append(float("inf"))
		else:
			transformed_costs.append(graph.es[i]["weight"] - d_target + d_source)
	return transformed_costs


# returns psycopg result as a python list
def clean_list(psycopg_list):
	clean = []
	for p in psycopg_list:
		clean.append(p[0])
	return clean


# returns points that intersect map
def get_points(cursor, map_name, points_name):
	cursor.execute("select distinct ST_snaptogrid(pun_geom, 0.00001) from %s, %s\
		 where st_intersects(st_snaptogrid(pun_geom, 0.00001), st_snaptogrid(camino, 0.00001));",
								 (AsIs(map_name), AsIs(points_name)))
	points_list = cursor.fetchall()
	return clean_list(points_list)


# returns capital cities
def get_capitals(cursor):
	map_name = "capitales_regionales"
	cursor.execute("select ST_snaptogrid(pun_geom, 0.00001) from %s;", (AsIs(map_name),))
	return clean_list(cursor.fetchall())


if __name__ == "__main__":
	main(sys.argv)
