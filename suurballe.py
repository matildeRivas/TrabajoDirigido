from igraph import *
import psycopg2
from psycopg2.extensions import AsIs
import sys
import pprint
from config import config


# file must have same name as paths table
def main(argv):
	if (len(sys.argv) < 4 or len(sys.argv) > 4):
		print(
			"Debe ingresar nombre de carpeta de archivos con lista de aristas y costos, nombre de tabla con puntos a conectar")
	else:
		g = Graph(directed=False)
		# g.add_vertices(9)
		# g.add_edges(((0, 1), (1, 2), (2, 3), (0, 4), (4, 3), (4, 5), (3, 5), (3, 7), (5, 6), (6, 7), (7, 8)))
		# g.es["weight"] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

		# suurballe(g, 0, False)
		folder_name = argv[1]
		points_name = argv[2]
		conn = None
		try:
			# read connection parameters
			params = config()
			# connect to the PostgreSQL server
			print('Connecting to the PostgreSQL database')
			conn = psycopg2.connect(**params)
			print('Connected!\n')
			# create a cursor
			cursor = conn.cursor()
			# conn.cursor will return a cursor object, you can use this cursor to perform queries
			cursor = conn.cursor()
			# execute queries
			# create a results table
			cursor.execute(
				"CREATE TABLE IF NOT EXISTS caminos_comunas  (id int generated by default as identity PRIMARY KEY, comuna_origen int, comuna_destino int, costo int, tipo varchar(250), tabla_origen varchar(250), geom geometry);")
			# close communication with the PostgreSQL database server
			for root, dirs, files in os.walk(folder_name):
				for filename in files:
					main_suurballe(filename, points_name, cursor)
			cursor.close()
			# commit the changes
			conn.commit()
		except (Exception, psycopg2.DatabaseError) as error:
			print(error)
		finally:
			if conn is not None:
				conn.close()

		main_suurballe(sys.argv[1], sys.argv[2], sys.argv[3])


def main_suurballe(graph_file, points_name, cursor):
	map_name = graph_file.split(".")[0]
	graph = read(graph_file, format='ncol', directed=False)
	cursor.execute("select pun_geom from %s p, %s c where ST_Intersects(ST_snaptogrid(pun_geom, 0.00001), camino)",
								 (AsIs(points_name), AsIs(map_name)))


# todo: por cada punto en puntos por conectar, hacer suurballe. Guardar info

# print(suurballe(g, g.vs.find("0101000020E61000006FD8B628B36752C0FB449E245D8F45C0").index, False))


def suurballe(graph, vertex, target_list, directed=False):
	graph.es["label"] = graph.es["weight"]
	graph.to_directed()
	# path to target vertices
	edge_path = graph.get_shortest_paths(vertex, weights="weight", to=target_list, output="epath")
	tree_edges = []
	for e in edge_path:
		tree_edges = list(set(tree_edges) | set(e))
	# distance to all vertices
	distance = graph.shortest_paths(vertex, weights="weight")[0]
	shortest_path = get_edges(graph, edge_path)
	# problem_vertex contains vertices without two paths
	problem_vertex = []
	result = []
	success = []

	# create transformed graph Gv for each V. Future: one unified graph
	for t in range(len(target_list)):
		v = graph.vs.find(target_list[t]).index
		if (distance[v] != float("inf") and target_list[t] != vertex):
			gv = Graph(directed=True)
			gv.add_vertices(len(graph.vs))
			reverse_edges(gv, graph, edge_path, t)
			gv.es["weight"] = transform_costs(graph, distance)
			transformed_path = gv.get_shortest_paths(vertex, weights="weight", to=target_list, output="epath")
			shortest_transformed = get_edges(gv, transformed_path)[0]
			# unify paths discarding edges that are in both paths
			for (x, y) in shortest_transformed:
				if (y, x) in shortest_path[t]:
					shortest_path[t].remove((y, x))
					shortest_transformed.remove((x, y))
			union = shortest_path[t] + shortest_transformed
			path_1 = get_path(union, vertex, v)
			try:
				path_2 = get_path(union, vertex, v)
				#success.append(v, path_1, path_2)
				pair = (path_1, path_2)
				result.append(pair)
			except Exception:
				result.append(path_1)
				problem_vertex.append(v)

		# if vertex is unreachable
		elif distance[v] == float("inf"):
			result.append([])
			problem_vertex.append(v)

		else:
			result.append([])
	print(result)
	return result


def reverse_edges(gv, graph, edge_path, v):
	for e in range(len(graph.get_edgelist())):
		edge = graph.es[e]
		source = edge.source
		target = edge.target
		if e in edge_path[v]:
			gv.add_edge(target, source)
		else:
			gv.add_edge(source, target)


# plot(gv, layout=layout)

def get_edges(graph, edge_path):
	edges = graph.get_edgelist()
	edges_as_pairs = []
	for path in edge_path:
		path_pairs = []
		for e in path:
			path_pairs.append(edges[e])
		edges_as_pairs.append(path_pairs)
	return edges_as_pairs


def get_path(edges, source, target):
	path = []
	edges.sort(key=lambda x: (x[1], x[0]))
	try:
		current = search_tuple(edges, target)
		path.append(current)
		while (current[0] != source):
			current = search_tuple(edges, current[0])
			path.append(current)
	except Exception:
		raise Exception
	return path


def search_tuple(tups, elem):
	result = list(filter(lambda tup: tup[1] == elem, tups))
	try:
		tups.remove(result[0])
		return result[0]
	except IndexError:
		raise Exception


# todo: raise exception


def transform_costs(graph, distance):
	transformed_costs = []
	for i in range(len(graph.es)):
		d_target = distance[graph.es[i].target]
		d_source = distance[graph.es[i].source]
		if d_target == float("inf") or d_source == float("inf"):
			transformed_costs.append(float("inf"))
		else:
			transformed_costs.append(graph.es[i]["weight"] - d_target + d_source)
	return transformed_costs


if __name__ == "__main__":
	main(sys.argv)
