from igraph import *
import psycopg2
from psycopg2.extensions import AsIs
from psycopg2.extras import execute_values
import sys
from config import config
import numpy as np
import datetime

from pprint import pprint


def main(argv):
	if (len(sys.argv) < 3 or len(sys.argv) > 3):
		print(
			"Debe ingresar nombre de mapa de caminos y nombre de mapa con puntos a conectar")
	else:
		map_name = argv[1]
		points_name = argv[2]
		conn = None
		try:
			# read connection parameters
			params = config()
			# connect to the PostgreSQL server
			print('Connecting to the PostgreSQL database')
			conn = psycopg2.connect(**params)
			print('Connected!\n')
			# create a cursor
			# conn.cursor will return a cursor object, you can use this cursor to perform queries
			cursor = conn.cursor()
			# execute queries
			currentTime = datetime.datetime.now()
			total_cost = build_paths(map_name, points_name, cursor)
			timeDelta = datetime.datetime.now() - currentTime
			# close communication with the PostgreSQL database server
			cursor.close()
			# commit the changes
			conn.commit()
			print(timeDelta)
			print("Costo total de construcci√≥n: ", total_cost)
		except (Exception, psycopg2.DatabaseError) as error:
			print(error)
		finally:
			if conn is not None:
				conn.close()


# create table with segments that need to be built
def build_paths(map_name, points_name, cursor):
	# create a results table
	needed_paths_name = map_name + "_suurballe"
	paths_to_build = map_name + "_construccion"
	cursor.execute(
		"CREATE TABLE IF NOT EXISTS %s  (path_id int, id int generated by default as identity PRIMARY KEY);",
		(AsIs(needed_paths_name),))
	find_paths(map_name, points_name, cursor, needed_paths_name)
	cursor.execute(
		"CREATE TABLE %s AS SELECT distinct m.camino, m.costo, c.path_id FROM %s m, %s c WHERE c.path_id = m.id AND m.costo != 0;",
		(AsIs(paths_to_build), AsIs(map_name), AsIs(needed_paths_name)))
	cursor.execute("select sum(costo) from %s;", (AsIs(paths_to_build),))
	cost = cursor.fetchone()[0]
	return cost


# find two disjoint paths between each pair of points, except for capital cities
def find_paths(map_name, points_name, cursor, needed_paths_name):
	# create graph from map linestrings, in which the vertex name is its postgis geometry, edge weight is the building cost and edge id is the corresponding id in table
	cursor.execute("select origen, fin, id, costo from %s where camino notnull;", (AsIs(map_name),))
	edges = cursor.fetchall()
	graph = Graph.TupleList(edges, directed=False, vertex_name_attr="name", edge_attrs=("id", "weight"))

	# get valid points (comunas)
	points = get_points(cursor, points_name, map_name)
	# create a grid to mark found paths
	points_grid = np.zeros((len(points), len(points)))
	# fill the grid's diagonal
	np.fill_diagonal(points_grid, 2)
	# get capital cities and peripheral points
	capitales = get_points(cursor, "capitales_regionales")
	limitrofes = get_points(cursor, "limitrofes")

	# for each point we must connect
	for p in range(len(points)):
		print("buscando desde comuna ", p)
		geom = points[p]
		# list of target comunas
		target = compute_targets(graph, points, points_grid, p)
		# source vertex associated to p
		s = graph.vs.find(name=geom)
		# if source is an isolated point, it only needs 1 path
		if geom in limitrofes:
			paths = get_single_path(graph, s, target)
			all_ids = process_paths(paths, p, graph, points, target, points_grid)
			flattened_ids = [y for x in all_ids for y in x]
		else:
			# list of disjoint paths from s to each target
			paths = suurballe(graph, s, target)
			# process paths to obtain the corresponding table IDs
			all_ids = process_paths(paths, p, graph, points, target, points_grid)
			# capitals must have three paths
			if geom in capitales:
				thrid_path = find_third_path(graph, s, all_ids, target, points_grid)
				all_ids = all_ids + thrid_path
			# add IDs to psql table
			flattened_ids = [y for x in all_ids for y in x]
		update_table(needed_paths_name, cursor, flattened_ids)
	pprint(points_grid)


# Process the paths obtained, filling the grid accordingly and returning all edges' ID
def process_paths(paths, p, graph, points, target, points_grid):
	all_ids = []
	# for each comuna's paths
	for path in paths:
		# first and second are tuple lists like ((i, j), id)
		first = path[0]
		second = path[1]
		# obtain target point corresponding to paths
		target_index = paths.index(path)
		point_index = points.index(graph.vs[target[target_index]]['name'])

		# fill points grid accordingly
		not_empty = fill_grid(points_grid, p, point_index, first, second)

		# add paths to list of needed paths
		if not_empty:
			path_ids = []
			for (i, j), id in first + second:
				path_ids.append((id,))
			all_ids.append(path_ids)
	return all_ids


# Returns list of shortest paths from source to each target in target_list
def get_single_path(graph, source, target_list):
	paths = graph.get_shortest_paths(source, weights="weight", to=target_list, output="epath")
	return get_edges(graph, paths)


# returns the points that don't yet have 2 paths to 'p'
def compute_targets(graph, points, points_grid, p):
	target = []
	# for each point
	for q in range(len(points)):
		# if it hasn't been computed
		if points_grid[p][q] == 0:
			t = graph.vs.find(name=points[q])
			target.append(t.index)
	return target


# fills points grid given paths from source to target and returns if there paths were not empty
def fill_grid(points_grid, source_index, target_index, first, second):
	# si ambos caminos existen
	if first != [] and second != []:
		points_grid[source_index][target_index] += 2
		points_grid[target_index][source_index] += 2
		return True
	elif (first != [] and second == []) or (second != [] and first == []):
		points_grid[source_index][target_index] += 1
		points_grid[target_index][source_index] += 1
		return True
	else:
		return False


# returns two disjoint shortest paths from source vertex to each point in target_list
def suurballe(graph, source, target_list, directed=False):
	if directed == False:
		graph.to_directed()
	# get shortest path to target vertices using Dijkstra
	edge_path = graph.get_shortest_paths(source, weights="weight", to=target_list, output="epath")

	# get shortest distance to all vertices using Dijkstra
	distance = graph.shortest_paths(source, weights="weight")[0]

	shortest_path = get_edges(graph, edge_path)
	# problem_vertex contains vertices without two paths
	problem_vertex = []
	result = []

	# create transformed graph Gv for each V. Future: one unified graph
	for t in range(len(target_list)):
		v = graph.vs.find(target_list[t]).index
		if (distance[v] != float("inf") and target_list[t] != source):
			gv = create_graph(graph, distance, edge_path, t)
			transformed_path = gv.get_shortest_paths(source, weights="weight", to=target_list[t], output="epath")
			shortest_transformed = get_edges(gv, transformed_path)[0]
			# unify paths discarding edges that are in both paths
			union = unify_paths(shortest_transformed, shortest_path[t])
			# obtain paths from union
			path_1 = get_path(union, source.index, v)
			try:
				path_2 = get_path(union, source.index, v)
				# success.append(v, path_1, path_2)
				pair = (path_1, path_2)
				result.append(pair)
			except Exception:
				result.append((path_1, []))
				problem_vertex.append(v)
		# if vertex is unreachable
		elif distance[v] == float("inf"):
			result.append(([], []))
			problem_vertex.append(v)

		else:
			result.append([])
	return result


# find a third disjoint path between source and target
def find_third_path(graph, source, path_ids, target, points_grid):
	paths = []
	for i in range(len(path_ids)):
		# for psql reasons the format is (id,)
		edge_index = graph.es.select(lambda edge: (edge["id"],) in path_ids[i])
		# copy the graph so we can delete the edges
		graph_copy = graph.copy()
		graph_copy.delete_edges(edge_index)
		# we only need the first element because there's only one target
		path = graph_copy.get_shortest_paths(source, weights="weight", to=target[i], output="epath")[0]
		for s in range(len(path)):
			# obtain actual edge id
			id = graph_copy.es.find(path[s])["id"]
			path[s] = id
		update_grid(points_grid, source, target[i])
		paths.append(path)
	return paths


# insert paths into table
def update_table(table_name, cursor, path_ids):
	if path_ids:
		query = "insert into " + table_name + " (path_id) values %s;"
		execute_values(cursor, query, path_ids)


# sum 1 in specific point
def update_grid(points_grid, source, target):
	points_grid[source][target] += 1
	points_grid[target][source] += 1


# returns copy of graph in which tree edges are reversed and edge weights are transformed for Suurballe
def create_graph(original_graph, distance, edge_path, target):
	gv = Graph(directed=True)
	gv.add_vertices(len(original_graph.vs))
	reverse_edges(gv, original_graph, edge_path, target)
	gv.es["weight"] = transform_attributes(original_graph, distance)
	return gv


# returns union of paths without complement edges
def unify_paths(path1, path2):
	for ((x, y), z) in path1:
		if ((y, x), z) in path2:
			path2.remove(((y, x), z))
			path1.remove(((x, y), z))
	return path2 + path1


# flips edges in gv that are in edge_path
def reverse_edges(gv, graph, edge_path, v):
	gv_edge_id = []
	for e in range(len(graph.get_edgelist())):
		edge = graph.es[e]
		source = edge.source
		target = edge.target
		if e in edge_path[v]:
			gv.add_edge(target, source)
			gv_edge_id.append(edge["id"])
		else:
			gv.add_edge(source, target)
			gv_edge_id.append(edge["id"])
	gv.es["id"] = gv_edge_id


# returns edges in edge_path as source and target IDs and edge ID
def get_edges(graph, edge_path):
	edges = graph.get_edgelist()
	edges_as_pairs = []
	for path in edge_path:
		path_pairs = []
		for e in path:
			path_pairs.append((edges[e], graph.es[e]["id"]))
		edges_as_pairs.append(path_pairs)
	return edges_as_pairs


# constructs a path from source to target with given edges
def get_path(edges, source, target):
	path = []
	edges.sort(key=lambda x: (x[1], x[0]))
	try:
		current = search_tuple(edges, target)
		path.append(current)
		while (current[0][0] != source):
			current = search_tuple(edges, current[0][0])
			path.append(current)
	except Exception:
		raise Exception
	return path


# looks for pair in which the target vertix matches with elem
def search_tuple(tups, elem):
	result = list(filter(lambda tup: tup[0][1] == elem, tups))
	try:
		tups.remove(result[0])
		return result[0]
	except IndexError:
		raise Exception


# transform edge_costs according to Suurballe algorithm
def transform_attributes(graph, distance):
	transformed_costs = []
	for i in range(len(graph.es)):
		d_target = distance[graph.es[i].target]
		d_source = distance[graph.es[i].source]
		if d_target == float("inf") or d_source == float("inf"):
			transformed_costs.append(float("inf"))
		else:
			transformed_costs.append(graph.es[i]["weight"] - d_target + d_source)
	return transformed_costs


# returns psycopg result as a python list
def clean_list(psycopg_list):
	clean = []
	for p in psycopg_list:
		clean.append(p[0])
	return clean


# returns points from a table, if map_name is specified, only returns points that intersect map
def get_points(cursor, points_name, map_name=None):
	if map_name == None:
		cursor.execute("select ST_snaptogrid(pun_geom, 0.00001) from %s;", (AsIs(points_name),))
		return clean_list(cursor.fetchall())
	else:
		cursor.execute("select distinct ST_snaptogrid(pun_geom, 0.00001) from %s, %s\
				 where st_intersects(st_snaptogrid(pun_geom, 0.00001), st_snaptogrid(camino, 0.00001));",
									 (AsIs(map_name), AsIs(points_name)))
		points_list = cursor.fetchall()
		return clean_list(points_list)


if __name__ == "__main__":
	main(sys.argv)
