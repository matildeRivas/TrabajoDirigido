from igraph import *
import psycopg2
from psycopg2.extensions import AsIs
from psycopg2.extras import execute_values
import sys
from config import config
import numpy as np
import datetime
import warnings
from pprint import pprint
import sys


def main(argv):
	if (len(sys.argv) < 3 or len(sys.argv) > 3):
		print(
			"Debe ingresar nombre de mapa de caminos y nombre de mapa con puntos a conectar")
	else:
		map_name = argv[1]
		points_name = argv[2]
		conn = None
		try:
			# read connection parameters
			params = config()
			# connect to the PostgreSQL server
			print('Connecting to the PostgreSQL database')
			conn = psycopg2.connect(**params)
			print('Connected!\n')
			# create a cursor
			# conn.cursor will return a cursor object, you can use this cursor to perform queries
			cursor = conn.cursor()
			# execute queries
			currentTime = datetime.datetime.now()
			total_cost = build_paths(map_name, points_name, cursor)
			timeDelta = datetime.datetime.now() - currentTime
			# close communication with the PostgreSQL database server
			cursor.close()
			# commit the changes
			conn.commit()
			print(timeDelta)
			print("Costo total de construcci√≥n: ", total_cost)
		except (Exception, psycopg2.DatabaseError) as error:
			print(error)
		finally:
			if conn is not None:
				conn.close()


# create table with segments that need to be built
def build_paths(map_name, points_name, cursor):
	# create a results table
	needed_paths_name = map_name + "_fast3"
	paths_to_build = map_name + "_construccion_fast3"
	cursor.execute("create table if not exists costs_table (type varchar, cost_per_km int);")
	cursor.execute("INSERT INTO costs_table VALUES ('nada', 25000), ('postacion', 17000), ('fibra', 0), ('ferry', 35000);")
	cursor.execute(
		"CREATE TABLE IF NOT EXISTS %s  (path_id int, id int generated by default as identity PRIMARY KEY);",
		(AsIs(needed_paths_name),))
	find_paths(map_name, points_name, cursor, needed_paths_name)
	cursor.execute(
		"CREATE TABLE %s AS SELECT distinct m.camino, m.costo, c.path_id FROM %s m, %s c WHERE c.path_id = m.id AND m.costo != 0;",
		(AsIs(paths_to_build), AsIs(map_name), AsIs(needed_paths_name)))
	cursor.execute("select sum(costo) from %s;", (AsIs(paths_to_build),))
	cost = cursor.fetchone()[0]
	return cost

def suurballe(graph, source, target_list, file1, i, directed=False):
	print("SOURCE: ",source)
	if directed == False:
		graph.to_directed()
	# get shortest path to target vertices using Dijkstra
	edge_path = graph.get_shortest_paths(source, weights="weight", to=target_list, output="epath")

	# get shortest distance to all vertices using Dijkstra
	distance = graph.shortest_paths(source, weights="weight")[0]

	shortest_path = get_edges(graph, edge_path)
	# problem_vertex contains vertices without two paths
	problem_vertex = []
	result = []

	# create transformed graph Gv for each V. Future: one unified graph
	for t in range(len(target_list)):
		v = graph.vs.find(target_list[t]).index
		if (distance[v] != float("inf") and target_list[t] != source):
			gv = create_graph(graph, distance, edge_path, t)
			transformed_path = gv.get_shortest_paths(source, weights="weight", to=target_list[t], output="epath")
			shortest_transformed = get_edges(gv, transformed_path)[0]
			# unify paths discarding edges that are in both paths
			union = unify_paths(shortest_transformed, shortest_path[t])
			# obtain paths from union
			path_1 = get_path(union, source.index, v, file1, i)
			try:
				path_2 = get_path(union, source.index, v, file1, i)
				# success.append(v, path_1, path_2)
				pair = (path_1, path_2)
				result.append(pair)
			except Exception:
				result.append((path_1, []))
				problem_vertex.append(v)
		# if vertex is unreachable
		elif distance[v] == float("inf"):
			result.append(([], []))
			problem_vertex.append(v)

		else:
			result.append([])
	
	return result

# find two disjoint paths between each pair of points, except for capital cities
def find_paths(map_name, points_name, cursor, needed_paths_name):
	# create graph from map linestrings, in which the vertex name is its postgis geometry, edge weight is the building cost and edge id is the corresponding id in table
	cursor.execute("select origen, fin, id, costo from %s where camino notnull;", (AsIs(map_name),))
	edges = cursor.fetchall()
	graph = Graph.TupleList(edges, directed=False, vertex_name_attr="name", edge_attrs=("id", "weight"))

	# get valid points (comunas)
	points = get_points(cursor, points_name, map_name)
	# create a grid to mark found paths
	points_grid = np.zeros((len(points), len(points)))
	# fill the grid's diagonal
	np.fill_diagonal(points_grid, 2)
	# get capital cities and peripheral points
	capitales = get_points(cursor, "capitales_regionales")
	limitrofes = get_points(cursor, "limitrofes")
	# for each point we must connect
	for p in range(len(points)):
		print("buscando desde comuna ", p)
		geom = points[p]
		# list of target comunas
		target = compute_targets(graph, points, points_grid, p)
		# source vertex associated to p
		s = graph.vs.find(name=geom)
		# if source is an isolated point, it only needs 1 path
		if geom in limitrofes:
			paths = get_single_path(graph, s, target)
			all_ids = list(process_paths(paths, p, graph, points, target, points_grid, single=True))
		else:
			# list of disjoint paths from s to each target	
			paths =shortest_pair_edgedisjoint_paths(graph, s, target)		
			# process paths to obtain the corresponding table IDs
			all_ids = process_paths(paths, p, graph, points, target, points_grid)
			# capitals must have three paths
			if geom in capitales and geom:
				# check if third connection hasn't been registered already
				if max_connections(points_grid, p) < 3:
					try:
						thrid_path = find_third_path(graph, points, s, p, all_ids, target, points_grid)
						all_ids = list(all_ids) + thrid_path
					except:
						point_geom, new_edge_id = create_shortest_connection(map_name, points_name, cursor, geom)
						graph.add_edge(geom, point_geom, weight=0, id=new_edge_id)
						fill_grid(points_grid, p, points.index(point_geom), 1)
						all_ids = list(all_ids).append(new_edge_id)
		# add IDs to psql table

		update_table(needed_paths_name, cursor, all_ids)
	pprint(points_grid)


# Process the paths obtained, filling the grid accordingly and returning all edges' ID
def process_paths(paths, p, graph, points, target, points_grid, single=False):
	all_ids = set([])
	# for each comuna's paths
	for path in paths:
		# obtain target point corresponding to paths
		target_index = paths.index(path)
		point_index = points.index(graph.vs[target[target_index]]['name'])
		inc = 0
		if single and path:
			# only one path per comuna
			inc = 1
			fill_grid(points_grid, p, point_index, inc)
			joint_paths = path
		elif path:
			# first and second are tuple lists like ((i, j), id)
			first = path[0]
			second = path[1]
			# how many paths were found
			inc = count_paths(first, second)
			# fill points grid accordingly
			fill_grid(points_grid, p, point_index, inc)
			joint_paths = first + second
		# add paths to list of needed paths
		if inc:
			for (i, j), id in joint_paths:
				all_ids.add((id,))
	return all_ids


# returns the number of paths found
def count_paths(first, second):
	if (first and second):
		return 2
	elif first or second:
		return 1
	else:
		return 0


# Returns list of shortest paths from source to each target in target_list
def get_single_path(graph, source, target_list):
	paths = graph.get_shortest_paths(source, weights="weight", to=target_list, output="epath")
	return get_edges(graph, paths)


# returns the points that don't yet have 2 paths to 'p'
def compute_targets(graph, points, points_grid, p):
	target = []
	# for each point
	for q in range(len(points)):
		# if it hasn't been computed
		if points_grid[p][q] == 0:
			t = graph.vs.find(name=points[q])
			target.append(t.index)
	return target


# fills points grid given paths from source to target according to increment
def fill_grid(points_grid, source_index, target_index, increment):
	points_grid[source_index][target_index] += increment
	points_grid[target_index][source_index] += increment

##############################################################################################################################################

#is_in_paths:: List[List[Int]] int -> bool
#Returns True if element is in list, false if it isnt
def is_in_paths(list, element):
        for e in list:
                for i in e:
                        if element==i:
                                return True
        return False

#new_costs:: Graph List[List] -> void
#Reduces the cost (weight) on all edges to c'(a,b) = c(a,b) + C(s,a) - C(s,b)
#The cost of the shortest path from s to any vertex is represented by C(s,vertex), where s is the root of "Shortest_paths_tree"
#and c(a,b) is the cost of the original Graph
#"Shortest_paths_tree" must be an edge-path
def new_costs(g,Shortest_paths_tree,target):
        new_costs = []
        for e in g.es:
                # e = (a,b)
                edges_a = Shortest_paths_tree[target.index(e.tuple[0])]
                edges_b = Shortest_paths_tree[target.index(e.tuple[1])]
                cost_a = 0
                cost_b = 0
                for i in edges_a:
                        cost_a += g.es[i]["weight"]
                for i in edges_b:
                        cost_b += g.es[i]["weight"]

                new_costs.append(e["weight"] + cost_a - cost_b)
                
        for i in range( len(new_costs) ):
                g.es[i]["weight"] = new_costs[i]    


#is_in_list:: List Int -> bool
#returns true if "element" is in "l", false if it isnt
def is_in_list(l,element):
        l.sort()
        piv = int(len(l)/2)
        s = 0
        e = len(l) - 1
        while e >= s:
                if l[piv] == element:
                        return True
                elif l[piv] > element:
                        e = piv - 1
                        piv = int((s + e)/2)
                elif l[piv] < element:
                        s = piv + 1
                        piv = int((s + e)/2)
        return False

#LCA:: Int Int List[List] List[Int] -> Int
#Returns the lowest common ancestor between "a" and "b" in "Shortest_path_tree"
def LCA(a,b,Shortest_path_tree,target,source):
	if a==source or b==source:
		return source
	if a==b:
		return a
	#List of a's parents 
	parents_a = [i for i in Shortest_path_tree[a][::-1]]
	#List of b's parents
	parents_b = [i for i in Shortest_path_tree[b][::-1]]
	maximum = max(len(parents_a), len(parents_b))
	if len(parents_a) == maximum:
		longest = parents_a
		shortest = parents_b
	else:
		longest = parents_b
		shortest = parents_a
	for element in shortest:
		if is_in_list(longest,element):
			return element
       
        
               


#aux_graph:: Graph List[List] List[Int] Int -> Tuple(Graph, List[List[List]])
#Returns the auxiliary graph constructed from "graph"
#and a list where list[x] has all the possibles candidates of predecessor(x) associated with its possible p(x) 
#where p(x) is head of the nontree edge in "graph" which caused the addition of the edge (predecessor(x),x) 
#in the shortest paths tree of the returned graph
def aux_graph(graph,Shortest_paths_tree,Shortest_paths_e,target,source):
	
	aux = Graph()
	aux.add_vertices(len(graph.vs))
	aux.to_directed(mutual=True)
	p = [None]*aux.vcount()
	
	for e in graph.es:
		# e = (a,b)
		a = e.tuple[0]
		b = e.tuple[1]
		weight = e["weight"]
		#For each non-tree edge
		if not is_in_paths(Shortest_paths_e, e.index):
			parents_b = Shortest_paths_tree[b]
			parents_a = Shortest_paths_tree[a]
			if parents_a == [] or parents_b == []:
				continue
			LCA_a_b = LCA(a,b,Shortest_paths_tree,target,source)
			if a==source:
				parents_a = [source]
			index_LCA_a = parents_a.index(LCA_a_b)
			index_LCA_b = parents_b.index(LCA_a_b)
			#path from LCA(a,b) to a in Shortest_paths_tree
			path = parents_a[index_LCA_a:]
			#path from LCA(a,b) to b in Shortest_paths_tree
			path_1 = parents_b[index_LCA_b:]
			no_duplicates = list(set(path_1) - set(path)) 
			path = path + no_duplicates
			existing_edges = len(aux.es)
			#adding new edges
			for vertex in path:
				old_edge = aux.get_eid(vertex,b,directed=True, error=False)
				#if it doesn't exist then add it
				if old_edge == -1:
					aux.add_edge(vertex,b)
			
					if p[b] == None:
						p[b] = []
					p[b].append([vertex,a])
				#if it exists then the cost must be minimum
				else:
					if weight < aux.es[old_edge]["weight"]:
						aux.es[old_edge]["weight"] = weight
						for pair in p[b]:
							if pair[0] == vertex:
								pair[1] = a
								break
			#Setting the cost of the recently added edges
			aux.es[existing_edges:]["weight"] = weight
	return (aux,p)

       

#g_path:: Graph List[Int] -> List[int]
#transforms a vertex-path to the corresponding edge-path
def g_path(graph, path):
	g_path = []
	for i, vertex in enumerate(path):
		if i+1 >= len(path):
			break
		g_path.append(graph.es.find(_source=path[i+1], _target=vertex).index)
	return g_path

        

#paths_generator:: Graph List[List[List]] List[List[Int]] List[Int] Vertex Graph List[List[Int]] -> List[pair[path, path]]
#Returns a list where in position x there is a list with the shortest pair of edge-disjoint paths
#from "source" to x
def paths_generator(graph, p, Shortest_paths_tree, target, source, original_graph, Shortest_edge_paths):
	paths = [None]*(len(target))

	for i,ver in enumerate(target):
		v = original_graph.vs.find(target[i]).index
		if ver == source:
			paths[i] = ([], [])
			pass
		else:
			try:
				graph_paths = graph.get_shortest_paths(source.index, weights="weight", to=ver, mode=OUT , output="vpath")
			except:
				graph_paths = [[]]

			graph_paths = graph_paths[0]
			if graph_paths == []:
				gp = Shortest_edge_paths[ver][::-1]
				edges = get_edges(original_graph, [gp])
				if gp == []:
					path = []
				else:
					path = edges[0]
				paths[i] = (path, [])
				continue
			marked = graph_paths
			marked.sort()
			path_1 = []
			path_2 = []
                	
            #ps = [p(x) for each x in marked]
			ps = [None]*len(marked)
			for c,v in enumerate(marked):
				if v == source.index:
					ps[c] = 0
				else:
					predecessor = graph.get_shortest_paths(source.index, weights="weight", to=v, mode=OUT , output="vpath")
					predecessor = predecessor[0][-2:][0]

                    #if p(v) hasn't been selected between the choices in "p"
					if type(p[v]) == list:
						for pair in p[v]:
							if pair[0] == predecessor:
								p[v] = pair[1]
								break
					ps[c] = p[v]

			#traverse
			path = [path_1, path_2]
			for counter in range(2):
				x = ver
				while x != source.index:
					path[counter].append(x)
					if is_in_list(marked,x):
						next = ps[marked.index(x)]
						ps.pop(marked.index(x))
						marked.remove(x)
					elif not is_in_list(marked,x):
						y = Shortest_paths_tree[x][-2:][0]
						next = y
					if next == source.index:
						path[counter].append(next)
					x = next
			gp1 = g_path(original_graph, path[1])
			gp2 = g_path(original_graph, path[0])
			edges_1 = get_edges(original_graph, [gp1])
			edges_2 = get_edges(original_graph, [gp2])
			path_1 = edges_1[0]
			path_2 = edges_2[0]
			pair = (path_1, path_2)
			paths[i] = pair
		
	return paths


                                
#shortest_pair_edgedisjoint_paths:: Graph, Vertex, List[Int] Bool -> List[pair[path, path]]
#Returns  the list of the shortest pairs of  edge-disjoint paths from "source" to every vertex in "target2".

def shortest_pair_edgedisjoint_paths(agraph, source, target2, directed=False):
	if directed==False:
		agraph.to_directed()
	graph = agraph.copy()
	target = range(len(graph.vs))
	graph.to_directed()

	#Step 1
	shortest_epaths = agraph.get_shortest_paths(source.index, weights="weight", to=target, mode=OUT , output="epath")
	shortest_vpaths = agraph.get_shortest_paths(source.index, weights="weight", to=target, mode=OUT , output="vpath")

	#Step 2
	new_costs(graph, shortest_epaths, target)

	#Step 3
	aux_data = aux_graph(graph, shortest_vpaths, shortest_epaths, target, source.index)
	aux_g = aux_data[0]
	p = aux_data[1]

	#Step 4
	target = target2
	paths = paths_generator(aux_g, p, shortest_vpaths, target, source, agraph, shortest_epaths)
	
	return paths

       
##############################################################################################################################################


# find a third disjoint path between source and target
def find_third_path(graph, points, source, p, path_ids, target, points_grid):
	# for psql reasons the format is (id,)
	edge_index = graph.es.select(lambda edge: (edge["id"],) in list(path_ids))
	# copy the graph so we can delete the edges
	graph_copy = graph.copy()
	graph_copy.delete_edges(edge_index)
	# find shortest distance to the other vertices
	new_distance = graph_copy.shortest_paths_dijkstra(source, target=target, weights="weight", mode=OUT)
	try:
		# select target with shortest distance
		target_index = target.index(min(new_distance[0]))
		points_index = points.index(graph.vs[target[target_index]]['name'])
		# get path to selected target
		path = graph_copy.get_shortest_paths(source, weights="weight", to=target[target_index], output="epath")[0]
		if path:
			new_path = []
			for s in path:
				# obtain actual edge id
				id = graph_copy.es.find(s)["id"]
				new_path.append(id)
			fill_grid(points_grid, p, points_index, 1)
		else:
			pass
	except Exception:
		# must create new path from scratch
		raise Exception()

	return path


# insert paths into table
def update_table(table_name, cursor, path_ids):
	if path_ids:
		query = "insert into " + table_name + " (path_id) values %s;"
		execute_values(cursor, query, path_ids)


# returns copy of graph in which tree edges are reversed and edge weights are transformed for Suurballe
def create_graph(original_graph, distance, edge_path, target):
	gv = Graph(directed=True)
	gv.add_vertices(len(original_graph.vs))
	reverse_edges(gv, original_graph, edge_path, target)
	gv.es["weight"] = transform_attributes(original_graph, distance)
	return gv


# returns union of paths without complement edges
def unify_paths(path1, path2):
	for ((x, y), z) in path1:
		if ((y, x), z) in path2:
			path2.remove(((y, x), z))
			path1.remove(((x, y), z))
	return path2 + path1


# flips edges in gv that are in edge_path
def reverse_edges(gv, graph, edge_path, v):
	gv_edge_id = []
	for e in range(len(graph.get_edgelist())):
		edge = graph.es[e]
		source = edge.source
		target = edge.target
		if e in edge_path[v]:
			gv.add_edge(target, source)
			gv_edge_id.append(edge["id"])
		else:
			gv.add_edge(source, target)
			gv_edge_id.append(edge["id"])
	gv.es["id"] = gv_edge_id


# returns edges in edge_path as source and target IDs and edge ID
def get_edges(graph, edge_path):
	edges = graph.get_edgelist()
	edges_as_pairs = []
	for path in edge_path:
		path_pairs = []
		for e in path:
			path_pairs.append((edges[e], graph.es[e]["id"]))
		edges_as_pairs.append(path_pairs)
	return edges_as_pairs


# constructs a path from source to target with given edges
def get_path(edges, source, target, file1, i):
	path = []
	edges.sort(key=lambda x: (x[1], x[0]))
	
	


	#print("edges: ", edges)
	#print("source: ", source)
	#print("target: ", target)
	try:
	#	print("try")
		current = search_tuple(edges, target)
		path.append(current)
		while (current[0][0] != source):
			current = search_tuple(edges, current[0][0])
			path.append(current)
	except Exception:
		#print("exception", Exception)
		#file1.write("EXCEPTION\n")
		
		if edges == []:
			return []
		raise Exception

		
	
	return path


# looks for pair in which the target vertix matches with elem
def search_tuple(tups, elem):
	result = list(filter(lambda tup: tup[0][1] == elem, tups))
	try:
		tups.remove(result[0])
		return result[0]
	except IndexError:
		raise Exception


# transform edge_costs according to Suurballe algorithm
def transform_attributes(graph, distance):
	transformed_costs = []
	for i in range(len(graph.es)):
		d_target = distance[graph.es[i].target]
		d_source = distance[graph.es[i].source]
		if d_target == float("inf") or d_source == float("inf"):
			transformed_costs.append(float("inf"))
		else:
			transformed_costs.append(graph.es[i]["weight"] - d_target + d_source)
	return transformed_costs


# returns psycopg result as a python list
def clean_list(psycopg_list):
	clean = []
	for p in psycopg_list:
		clean.append(p[0])
	return clean


# returns points from a table, if map_name is specified, only returns points that intersect map
def get_points(cursor, points_name, map_name=None):
	if map_name == None:
		cursor.execute("select ST_snaptogrid(pun_geom, 0.00001) from %s;", (AsIs(points_name),))
		return clean_list(cursor.fetchall())
	else:
		cursor.execute("select distinct ST_snaptogrid(pun_geom, 0.00001) from %s, %s\
				 where st_intersects(st_snaptogrid(pun_geom, 0.00001), st_snaptogrid(camino, 0.00001));",
									 (AsIs(map_name), AsIs(points_name)))
		points_list = cursor.fetchall()
		return clean_list(points_list)


# returns max number of connections that p has
def max_connections(points_grid, p):
	return max(points_grid[p])


# creates the shortest connection from source to any comuna, returns
def create_shortest_connection(map_name, points_name, cursor, geom):
	# find building cost and point id of closest comuna
	cursor.execute(
		"select b.pun_geom, min(ST_DistanceSphere(a.pun_geom, b.pun_geom)) m from %s a,%s b where a.pun_geom=%s and a.pun_id != b.pun_id group by b.pun_geom order by m limit 1;",
		(AsIs(points_name), AsIs(points_name), geom))
	pun_geom, distance = cursor.fetchall()[0]
	cursor.execute("select cost_per_km from costs_table where type='nada';")
	path_cost = (distance / 1000) * cursor.fetchone()[0]
	# camino geometry, x1 float, y1 float, x2 float, y2 float, tipo varchar(255), id_origen int, largo float, costo int, tabla_origen varchar(255), origen geometry, fin geometry
	cursor.execute("insert into %s (camino, x1, y1, x2, y2, tipo, largo, costo, origen, fin )\
	 values (ST_makeline(%s, %s), ST_X(%s), ST_Y(%s),  ST_X(%s), ST_Y(%s), 'nada', ST_DistanceSphere(%s,%s), %s,%s, %s) returning id; ", \
								 (AsIs(map_name), geom, pun_geom, geom, geom, pun_geom, pun_geom, geom, pun_geom, path_cost, geom,
									pun_geom))
	edge_id = cursor.fetchone()[0]
	return pun_geom, edge_id


if __name__ == "__main__":
	main(sys.argv)

