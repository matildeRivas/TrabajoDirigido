from igraph import *
import psycopg2
from psycopg2.extensions import AsIs
from psycopg2.extras import execute_values
import sys
from config import config
import numpy as np
from pprint import pprint



def main(argv):
	if (len(sys.argv) < 3 or len(sys.argv) > 3):
		print(
			"Debe ingresar nombre de mapa de caminos y nombre de mapa con puntos a conectar")
	else:
		map_name = argv[1]
		points_name = argv[2]
		conn = None
		try:
			# read connection parameters
			params = config()
			# connect to the PostgreSQL server
			print('Connecting to the PostgreSQL database')
			conn = psycopg2.connect(**params)
			print('Connected!\n')
			# create a cursor
			# conn.cursor will return a cursor object, you can use this cursor to perform queries
			cursor = conn.cursor()
			# execute queries
			# create a results table
			CaminosComunas = map_name + "_comunas"
			cursor.execute(
				"CREATE TABLE IF NOT EXISTS %s  (path_id int, id int generated by default as identity PRIMARY KEY);", (AsIs(CaminosComunas),))
			# close communication with the PostgreSQL database server
			main_suurballe(map_name, points_name, cursor)
			cursor.close()
			# commit the changes
			conn.commit()
		except (Exception, psycopg2.DatabaseError) as error:
			print(error)
		finally:
			if conn is not None:
				conn.close()


def main_suurballe(map_name, points_name, cursor):
	cursor.execute("select origen, fin, id, costo from %s where camino notnull;", (AsIs(map_name),))
	edges = cursor.fetchall()
	graph = Graph.TupleList(edges, directed=False, vertex_name_attr="name", edge_attrs=("id", "weight"))
	cursor.execute("select distinct ST_snaptogrid(pun_geom, 0.00001) from %s, %s\
	 where st_intersects(st_snaptogrid(pun_geom, 0.00001), st_snaptogrid(camino, 0.00001));", (AsIs(map_name),AsIs(points_name)))
	points_list = cursor.fetchall()
	points = []
	for p in points_list:
		points.append(p[0])

	points_grid = np.zeros((len(points), len(points)))
	np.fill_diagonal(points_grid, 2)
	# por cada punto a conectar
	for p in range(len(points)):
		print("buscando comuna ",p)
		# lista de comunas a las que debe conectarse
		target = []
		# por cada otro
		for q in range(len(points)):
			# si no existe camino guardado
			if points_grid[p][q] == 0:
				t = graph.vs.find(name=points[q])
				target.append(t.index)
		# lista de caminos desde p a cada q
		s = graph.vs.find(name=points[p])
		paths = suurballe(graph, s, target)
		# por cada comuna
		for path in paths:
			# first y second son listas de tuplas ((i, j), id)
			first = path[0]
			second = path[1]
			target_index = paths.index(path)
			fill_grid(points_grid, p, target_index, first, second)
			# a√±adir caminos a lista de caminos a construir
			path_ids = []
			for (i, j), id in first + second:
				path_ids.append((id,))
			query = "insert into " + map_name + "_comunas (path_id) values %s;"
			execute_values(cursor, query , path_ids)
	print(points_grid)


def fill_grid(points_grid, source_index, target_index, first, second):
	# si ambos caminos existen
	if first != "[]" and second != "[]":
		points_grid[source_index][target_index] = 2
		points_grid[target_index][source_index] = 2
	elif (first != "[]" and second == "[]") or (second != "[]" and first == "[]"):
		points_grid[source_index][target_index] = 1
		points_grid[target_index][source_index] = 1


def suurballe(graph, vertex, target_list, directed=False):
	graph.to_directed()
	# path to target vertices
	edge_path = graph.get_shortest_paths(vertex, weights="weight", to=target_list, output="epath")
	tree_edges = []
	for e in edge_path:
		tree_edges = list(set(tree_edges) | set(e))
	# distance to all vertices
	distance = graph.shortest_paths(vertex, weights="weight")[0]
	shortest_path = get_edges(graph, edge_path)
	# problem_vertex contains vertices without two paths
	problem_vertex = []
	result = []

	# create transformed graph Gv for each V. Future: one unified graph
	for t in range(len(target_list)):
		v = graph.vs.find(target_list[t]).index
		if (distance[v] != float("inf") and target_list[t] != vertex):
			gv = create_graph(graph, distance, edge_path, t)
			transformed_path = gv.get_shortest_paths(vertex, weights="weight", to=target_list, output="epath")
			shortest_transformed = get_edges(gv, transformed_path)[0]
			# unify paths discarding edges that are in both paths
			union = unify_paths(shortest_transformed, shortest_path[t])
			path_1 = get_path(union, vertex.index, v)
			try:
				path_2 = get_path(union, vertex.index, v)
				# success.append(v, path_1, path_2)
				pair = (path_1, path_2)
				result.append(pair)
			except Exception:
				result.append((path_1, []))
				problem_vertex.append(v)

		# if vertex is unreachable
		elif distance[v] == float("inf"):
			result.append(([], []))
			problem_vertex.append(v)

		else:
			result.append([])
	return result


def create_graph(original_graph, distance, edge_path, target):
	gv = Graph(directed=True)
	gv.add_vertices(len(original_graph.vs))
	reverse_edges(gv, original_graph, edge_path, target)
	gv.es["weight"] = transform_attributes(original_graph, distance)
	return gv


def unify_paths(path1, path2 ):
	for ((x, y), z) in path1:
		if ((y, x), z) in path2:
			path2.remove(((y, x), z))
			path1.remove(((x, y), z))
	return path2 + path1


def reverse_edges(gv, graph, edge_path, v):
	gv_edge_id = []
	for e in range(len(graph.get_edgelist())):
		edge = graph.es[e]
		source = edge.source
		target = edge.target
		if e in edge_path[v]:
			gv.add_edge(target, source)
			gv_edge_id.append(edge["id"])
		else:
			gv.add_edge(source, target)
			gv_edge_id.append(edge["id"])
	gv.es["id"] = gv_edge_id


# plot(gv, layout=layout)

def get_edges(graph, edge_path):
	edges = graph.get_edgelist()
	edges_as_pairs = []
	for path in edge_path:
		path_pairs = []
		for e in path:
			path_pairs.append((edges[e], graph.es[e]["id"]))
		edges_as_pairs.append(path_pairs)
	return edges_as_pairs


def get_path(edges, source, target):
	path = []
	edges.sort(key=lambda x: (x[1], x[0]))
	try:
		current = search_tuple(edges, target)
		path.append(current)
		while (current[0][0] != source):
			current = search_tuple(edges, current[0][0])
			path.append(current)
	except Exception:
		raise Exception
	return path


def search_tuple(tups, elem):
	result = list(filter(lambda tup: tup[0][1] == elem, tups))
	try:
		tups.remove(result[0])
		return result[0]
	except IndexError:
		raise Exception


def transform_attributes(graph, distance):
	transformed_costs = []
	for i in range(len(graph.es)):
		d_target = distance[graph.es[i].target]
		d_source = distance[graph.es[i].source]
		if d_target == float("inf") or d_source == float("inf"):
			transformed_costs.append(float("inf"))
		else:
			transformed_costs.append(graph.es[i]["weight"] - d_target + d_source)
	return transformed_costs


if __name__ == "__main__":
	main(sys.argv)
